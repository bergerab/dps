<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>dplang.dplang.lang API documentation</title>
<meta name="description" content="DPL - An embedded domain specific langauge for data processing â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dplang.dplang.lang</code></h1>
</header>
<section id="section-intro">
<p>DPL - An embedded domain specific langauge for data processing.</p>
<p>The language supports two kinds of computations on time-series data:
1. Point-wise
2. Windowed</p>
<p>Point-wise computations are done on each datapoint. This includes addition,
subtraction, etc&hellip;</p>
<p>Windowed computations involve taking collections of datapoints and performing
some aggregation on them. This includes averaging, finding the median, total
harmonic distortion (THD), etc&hellip;</p>
<p>The language consists of SignalExpressions, OperatorExpressions, and WindowExpressions.
It is "compiled" into Python functions (represented by a Signal object). The purpose of the
language is to determine which input signals are needed to perform the computation, and
provide a more compact implementation of data processing computations.</p>
<p>Point-wise example:</p>
<pre><code>Va + Vb + Vc
</code></pre>
<p>Windowed example:</p>
<pre><code>average(window(Va, 1s))
</code></pre>
<p>Any free variables are assumed to be signal names (for example "Va" in the window example).
Durations can be expressed as identifiers such as "1s", "10ms", "2m", "12h", etc&hellip;</p>
<p>Computations can have either signals or constants. Constants are useful for systems which
have some rated values that have to be compared against. Signals represent direct connections
to wires in the external system.</p>
<p>The implementation uses Python's parser (found in the builtin ast module). It is a subset of
Python with different semantics. Computations can be made with normal operators such as '+' or
'-' for point-wise computations, and windowed computations can use the builtin functions for
'window' and 'thd'.</p>
<p>The language is case-insensitive to avoid issues with naming signals. This makes the difference
between 'VA', 'Va', and 'va' irrelevant.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
DPL - An embedded domain specific langauge for data processing.

The language supports two kinds of computations on time-series data:
    1. Point-wise
    2. Windowed

Point-wise computations are done on each datapoint. This includes addition, 
subtraction, etc...

Windowed computations involve taking collections of datapoints and performing
some aggregation on them. This includes averaging, finding the median, total
harmonic distortion (THD), etc...

The language consists of SignalExpressions, OperatorExpressions, and WindowExpressions.
It is &#34;compiled&#34; into Python functions (represented by a Signal object). The purpose of the 
language is to determine which input signals are needed to perform the computation, and 
provide a more compact implementation of data processing computations.

Point-wise example:

```
Va + Vb + Vc
```

Windowed example:

```
average(window(Va, 1s))
```

Any free variables are assumed to be signal names (for example &#34;Va&#34; in the window example).
Durations can be expressed as identifiers such as &#34;1s&#34;, &#34;10ms&#34;, &#34;2m&#34;, &#34;12h&#34;, etc...

Computations can have either signals or constants. Constants are useful for systems which
have some rated values that have to be compared against. Signals represent direct connections
to wires in the external system.

The implementation uses Python&#39;s parser (found in the builtin ast module). It is a subset of
Python with different semantics. Computations can be made with normal operators such as &#39;+&#39; or
&#39;-&#39; for point-wise computations, and windowed computations can use the builtin functions for
&#39;window&#39; and &#39;thd&#39;.

The language is case-insensitive to avoid issues with naming signals. This makes the difference
between &#39;VA&#39;, &#39;Va&#39;, and &#39;va&#39; irrelevant.
&#39;&#39;&#39;

import ast
import re
from datetime import timedelta

class Expression:
    def compile(self):
        &#39;&#39;&#39;
        Compiles an AST of Signals, Operators, and Windows into a single Signal.
        &#39;&#39;&#39;
        raise Exception(&#39;compile() not implemented.&#39;)

    @staticmethod
    def compile(x):
        if isinstance(x, Expression):
            return x.compile()
        return x

class SignalExpression(Expression):
    &#39;&#39;&#39;
    An input signal for the computation
    &#39;&#39;&#39;
    def __init__(self, name):
        self.name = name
        
    def compile(self):
        &#39;&#39;&#39;
        Signal Expression -&gt; Signal Value
        &#39;&#39;&#39;
        return Signal(lambda dataset: dataset[self.name])

class ConstantExpression(Expression):
    def __init__(self, name):
        self.name = name
        
    def compile(self):
        &#39;&#39;&#39;
        Signal Expression -&gt; Signal Value
        &#39;&#39;&#39;
        return Signal(lambda dataset: dataset[self.name])

class NumberExpression(Expression):
    def __init__(self, n):
        self.n = n

    def compile(self):
        return Signal(lambda dataset: self.n)

class ApplicationExpression(Expression):
    &#39;&#39;&#39;
    A point-wise computation on signals
    &#39;&#39;&#39;

    functions = {
        &#39;+&#39;: lambda signals: sum(signals),
        &#39;average&#39;: lambda args: 2
    }
    
    def __init__(self, name, exprs):
        self.name = name.lower()
        self.exprs = exprs

    def is_supported(self):
        return self.name in [
            &#39;average&#39;,
            &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;//&#39;,
        ]

    def compile(self):
        &#39;&#39;&#39;
        Operator -&gt; Signal
        &#39;&#39;&#39;
        values = map(Expression.compile, self.exprs)
        def do_signal(dataset):
            f = functions[self.name]
            return f(map(lambda value: Signal.eval(value, dataset), values))
            
        return value.Signal(do_signal)

class WindowExpression(Expression):
    &#39;&#39;&#39;
    A windowed computation on signals

    If window size is less than amount of data recieved, throw error.
    The caller must check the window and ensure that the given data is a multiple of the window size.
    &#39;&#39;&#39;
    def __init__(self, expr, size=1, stride=1):
        self.expr = expr
        self.size = size
        self.stride = stride
        
    def compile(self):
        &#39;&#39;&#39;
        Window -&gt; Signal
        &#39;&#39;&#39;
        pass


class Signal:
    def __init__(self, f):
        &#39;&#39;&#39;
        f :: DataSet -&gt; a
        &#39;&#39;&#39;
        self.f = f

    @staticmethod
    def eval(x, dataset):
        if isinstance(x, Signal):
            return x.f(dataset)
        return x

    def run(self, input):
        def generator():
            yield 1
        return generator

time_pattern = re.compile(&#39;(\d+)(ms|s|m|h)&#39;)
&#39;&#39;&#39;
Times are represented as strings of the form:
200ms -&gt; 200 milliseconds
10s   -&gt; 10 seconds
3m    -&gt; 3 minutes
4h    -&gt; 4 hours
&#39;&#39;&#39;

unit_map = {
    &#39;ms&#39;: &#39;milliseconds&#39;,
    &#39;s&#39;: &#39;seconds&#39;,
    &#39;m&#39;: &#39;minutes&#39;,
    &#39;h&#39;: &#39;hours&#39;,
}
&#39;&#39;&#39;
A mapping from shorthand names to the names timedelta uses as keywords.
&#39;&#39;&#39;

def parse_time(id):
    &#39;&#39;&#39;
    Parses a string into a timedelta value
    &#39;&#39;&#39;
    result = time_pattern.search(id)
    if not result: return None
    magnitude, units = result.groups()
    return timedelta(**{ unit_map[units]: int(magnitude) })

class DPLCompiler(ast.NodeVisitor):
    def __init__(self, signal_names=[], constant_names=[]):
        self.signal_names = map(lambda x: x.lower(), signal_names)
        self.constant_names = map(lambda x: x.lower(), constant_names)
        self.ast = None

    # Restrict certain statements which are not useful
    def visit_Import(self, node):
        raise Exception(&#39;Import statements are not allowed&#39;)
    def visit_Raise(self, node):
        raise Exception(&#39;Raise statements are not allowed&#39;)
    def visit_For(self, node):
        raise Exception(&#39;For statements are not allowed&#39;)
    def visit_While(self, node):
        raise Exception(&#39;While statements are not allowed&#39;)
    def visit_With(self, node):
        raise Exception(&#39;With statements are not allowed&#39;)

    def visit_Module(self, node):
        return self.visit(node.body[0])

    def visit_Expr(self, node):
        return self.visit(node.value)

    def visit_Name(self, node):
        name = node.id.lower()
        if name in self.signal_names:
            return SignalExpression(node.id)
        if name in self.constant_names:
            return ConstantExpression(node.id)
        # if node is a valid function name
            # retunr the string
        raise Exception(&#39;Invalid name &#34;&#39; + node.id +&#39;&#34;&#39;)

    def visit_Str(self, node):
        time = parse_time(node.s)
        if time:
            return time
        raise Exception(&#39;Unable to parse time sting &#34;&#39; + node.s + &#39;&#34;. Must be of the form: (\d+)(ms|s|m|h)&#39;)

    def visit_Num(self, node):
        return NumberExpression(node.n)

    def visit_BinOp(self, node):
        left = self.visit(node.left)
        right = self.visit(node.right)
        op = node.op
        if isinstance(op, ast.Add):
            name = &#39;+&#39;
        elif isinstance(op, ast.Sub):
            name = &#39;-&#39;
        elif isinstance(op, ast.Mult):
            name = &#39;*&#39;            
        elif isinstance(op, ast.Div):
            name = &#39;/&#39;
        elif isinstance(op, ast.FloorDiv):
            name = &#39;//&#39;            
        else:
            raise Exception(&#39;Unsupported BinOp&#39;)
        return ApplicationExpression(name, [left, right])

    def visit_Call(self, node):
        return ApplicationExpression(node.func.id, list(map(lambda arg: self.visit(arg), node.args)))

def parse(code, signal_names=[], constant_names=[]):
    &#39;&#39;&#39;
    Given some string containing DPL source code, a list of signal names, and a list of constant names,
    generates a DPL AST.
    &#39;&#39;&#39;
    node = ast.parse(code)
    visitor = DPLCompiler(signal_names, constant_names)
    dpl_node = visitor.visit(node)
    return dpl_node

if __name__ == &#39;__main__&#39;:
    print(parse(&#39;&#39;&#39;
va
&#39;&#39;&#39;, [&#39;Va&#39;, &#39;Vb&#39;, &#39;Vc&#39;]))</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="dplang.dplang.lang.time_pattern"><code class="name">var <span class="ident">time_pattern</span></code></dt>
<dd>
<div class="desc"><p>Times are represented as strings of the form:
200ms -&gt; 200 milliseconds
10s
-&gt; 10 seconds
3m
-&gt; 3 minutes
4h
-&gt; 4 hours</p></div>
</dd>
<dt id="dplang.dplang.lang.unit_map"><code class="name">var <span class="ident">unit_map</span></code></dt>
<dd>
<div class="desc"><p>A mapping from shorthand names to the names timedelta uses as keywords.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dplang.dplang.lang.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>code, signal_names=[], constant_names=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Given some string containing DPL source code, a list of signal names, and a list of constant names,
generates a DPL AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(code, signal_names=[], constant_names=[]):
    &#39;&#39;&#39;
    Given some string containing DPL source code, a list of signal names, and a list of constant names,
    generates a DPL AST.
    &#39;&#39;&#39;
    node = ast.parse(code)
    visitor = DPLCompiler(signal_names, constant_names)
    dpl_node = visitor.visit(node)
    return dpl_node</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.parse_time"><code class="name flex">
<span>def <span class="ident">parse_time</span></span>(<span>id)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a string into a timedelta value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_time(id):
    &#39;&#39;&#39;
    Parses a string into a timedelta value
    &#39;&#39;&#39;
    result = time_pattern.search(id)
    if not result: return None
    magnitude, units = result.groups()
    return timedelta(**{ unit_map[units]: int(magnitude) })</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dplang.dplang.lang.ApplicationExpression"><code class="flex name class">
<span>class <span class="ident">ApplicationExpression</span></span>
<span>(</span><span>name, exprs)</span>
</code></dt>
<dd>
<div class="desc"><p>A point-wise computation on signals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ApplicationExpression(Expression):
    &#39;&#39;&#39;
    A point-wise computation on signals
    &#39;&#39;&#39;

    functions = {
        &#39;+&#39;: lambda signals: sum(signals),
        &#39;average&#39;: lambda args: 2
    }
    
    def __init__(self, name, exprs):
        self.name = name.lower()
        self.exprs = exprs

    def is_supported(self):
        return self.name in [
            &#39;average&#39;,
            &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;//&#39;,
        ]

    def compile(self):
        &#39;&#39;&#39;
        Operator -&gt; Signal
        &#39;&#39;&#39;
        values = map(Expression.compile, self.exprs)
        def do_signal(dataset):
            f = functions[self.name]
            return f(map(lambda value: Signal.eval(value, dataset), values))
            
        return value.Signal(do_signal)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dplang.dplang.lang.Expression" href="#dplang.dplang.lang.Expression">Expression</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dplang.dplang.lang.ApplicationExpression.functions"><code class="name">var <span class="ident">functions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dplang.dplang.lang.ApplicationExpression.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Operator -&gt; Signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self):
    &#39;&#39;&#39;
    Operator -&gt; Signal
    &#39;&#39;&#39;
    values = map(Expression.compile, self.exprs)
    def do_signal(dataset):
        f = functions[self.name]
        return f(map(lambda value: Signal.eval(value, dataset), values))
        
    return value.Signal(do_signal)</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.ApplicationExpression.is_supported"><code class="name flex">
<span>def <span class="ident">is_supported</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_supported(self):
    return self.name in [
        &#39;average&#39;,
        &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;//&#39;,
    ]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dplang.dplang.lang.ConstantExpression"><code class="flex name class">
<span>class <span class="ident">ConstantExpression</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstantExpression(Expression):
    def __init__(self, name):
        self.name = name
        
    def compile(self):
        &#39;&#39;&#39;
        Signal Expression -&gt; Signal Value
        &#39;&#39;&#39;
        return Signal(lambda dataset: dataset[self.name])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dplang.dplang.lang.Expression" href="#dplang.dplang.lang.Expression">Expression</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dplang.dplang.lang.ConstantExpression.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal Expression -&gt; Signal Value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self):
    &#39;&#39;&#39;
    Signal Expression -&gt; Signal Value
    &#39;&#39;&#39;
    return Signal(lambda dataset: dataset[self.name])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler"><code class="flex name class">
<span>class <span class="ident">DPLCompiler</span></span>
<span>(</span><span>signal_names=[], constant_names=[])</span>
</code></dt>
<dd>
<div class="desc"><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.
This function may return a value
which is forwarded by the <code>visit</code> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<p>Per default the visitor functions for the nodes are <code>'visit_'</code> +
class name of the node.
So a <code>TryFinally</code> node visit function would
be <code>visit_TryFinally</code>.
This behavior can be changed by overriding
the <code>visit</code> method.
If no visitor function exists for a node
(return value <code>None</code>) the <code>generic_visit</code> visitor is used instead.</p>
<p>Don't use the <code>NodeVisitor</code> if you want to apply changes to nodes during
traversing.
For this a special visitor exists (<code>NodeTransformer</code>) that
allows modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DPLCompiler(ast.NodeVisitor):
    def __init__(self, signal_names=[], constant_names=[]):
        self.signal_names = map(lambda x: x.lower(), signal_names)
        self.constant_names = map(lambda x: x.lower(), constant_names)
        self.ast = None

    # Restrict certain statements which are not useful
    def visit_Import(self, node):
        raise Exception(&#39;Import statements are not allowed&#39;)
    def visit_Raise(self, node):
        raise Exception(&#39;Raise statements are not allowed&#39;)
    def visit_For(self, node):
        raise Exception(&#39;For statements are not allowed&#39;)
    def visit_While(self, node):
        raise Exception(&#39;While statements are not allowed&#39;)
    def visit_With(self, node):
        raise Exception(&#39;With statements are not allowed&#39;)

    def visit_Module(self, node):
        return self.visit(node.body[0])

    def visit_Expr(self, node):
        return self.visit(node.value)

    def visit_Name(self, node):
        name = node.id.lower()
        if name in self.signal_names:
            return SignalExpression(node.id)
        if name in self.constant_names:
            return ConstantExpression(node.id)
        # if node is a valid function name
            # retunr the string
        raise Exception(&#39;Invalid name &#34;&#39; + node.id +&#39;&#34;&#39;)

    def visit_Str(self, node):
        time = parse_time(node.s)
        if time:
            return time
        raise Exception(&#39;Unable to parse time sting &#34;&#39; + node.s + &#39;&#34;. Must be of the form: (\d+)(ms|s|m|h)&#39;)

    def visit_Num(self, node):
        return NumberExpression(node.n)

    def visit_BinOp(self, node):
        left = self.visit(node.left)
        right = self.visit(node.right)
        op = node.op
        if isinstance(op, ast.Add):
            name = &#39;+&#39;
        elif isinstance(op, ast.Sub):
            name = &#39;-&#39;
        elif isinstance(op, ast.Mult):
            name = &#39;*&#39;            
        elif isinstance(op, ast.Div):
            name = &#39;/&#39;
        elif isinstance(op, ast.FloorDiv):
            name = &#39;//&#39;            
        else:
            raise Exception(&#39;Unsupported BinOp&#39;)
        return ApplicationExpression(name, [left, right])

    def visit_Call(self, node):
        return ApplicationExpression(node.func.id, list(map(lambda arg: self.visit(arg), node.args)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ast.NodeVisitor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dplang.dplang.lang.DPLCompiler.visit_BinOp"><code class="name flex">
<span>def <span class="ident">visit_BinOp</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_BinOp(self, node):
    left = self.visit(node.left)
    right = self.visit(node.right)
    op = node.op
    if isinstance(op, ast.Add):
        name = &#39;+&#39;
    elif isinstance(op, ast.Sub):
        name = &#39;-&#39;
    elif isinstance(op, ast.Mult):
        name = &#39;*&#39;            
    elif isinstance(op, ast.Div):
        name = &#39;/&#39;
    elif isinstance(op, ast.FloorDiv):
        name = &#39;//&#39;            
    else:
        raise Exception(&#39;Unsupported BinOp&#39;)
    return ApplicationExpression(name, [left, right])</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_Call"><code class="name flex">
<span>def <span class="ident">visit_Call</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Call(self, node):
    return ApplicationExpression(node.func.id, list(map(lambda arg: self.visit(arg), node.args)))</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_Expr"><code class="name flex">
<span>def <span class="ident">visit_Expr</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Expr(self, node):
    return self.visit(node.value)</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_For"><code class="name flex">
<span>def <span class="ident">visit_For</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_For(self, node):
    raise Exception(&#39;For statements are not allowed&#39;)</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_Import"><code class="name flex">
<span>def <span class="ident">visit_Import</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Import(self, node):
    raise Exception(&#39;Import statements are not allowed&#39;)</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_Module"><code class="name flex">
<span>def <span class="ident">visit_Module</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Module(self, node):
    return self.visit(node.body[0])</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Name(self, node):
    name = node.id.lower()
    if name in self.signal_names:
        return SignalExpression(node.id)
    if name in self.constant_names:
        return ConstantExpression(node.id)
    # if node is a valid function name
        # retunr the string
    raise Exception(&#39;Invalid name &#34;&#39; + node.id +&#39;&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_Num"><code class="name flex">
<span>def <span class="ident">visit_Num</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Num(self, node):
    return NumberExpression(node.n)</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_Raise"><code class="name flex">
<span>def <span class="ident">visit_Raise</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Raise(self, node):
    raise Exception(&#39;Raise statements are not allowed&#39;)</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_Str"><code class="name flex">
<span>def <span class="ident">visit_Str</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Str(self, node):
    time = parse_time(node.s)
    if time:
        return time
    raise Exception(&#39;Unable to parse time sting &#34;&#39; + node.s + &#39;&#34;. Must be of the form: (\d+)(ms|s|m|h)&#39;)</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_While"><code class="name flex">
<span>def <span class="ident">visit_While</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_While(self, node):
    raise Exception(&#39;While statements are not allowed&#39;)</code></pre>
</details>
</dd>
<dt id="dplang.dplang.lang.DPLCompiler.visit_With"><code class="name flex">
<span>def <span class="ident">visit_With</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_With(self, node):
    raise Exception(&#39;With statements are not allowed&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dplang.dplang.lang.Expression"><code class="flex name class">
<span>class <span class="ident">Expression</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Expression:
    def compile(self):
        &#39;&#39;&#39;
        Compiles an AST of Signals, Operators, and Windows into a single Signal.
        &#39;&#39;&#39;
        raise Exception(&#39;compile() not implemented.&#39;)

    @staticmethod
    def compile(x):
        if isinstance(x, Expression):
            return x.compile()
        return x</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dplang.dplang.lang.ApplicationExpression" href="#dplang.dplang.lang.ApplicationExpression">ApplicationExpression</a></li>
<li><a title="dplang.dplang.lang.ConstantExpression" href="#dplang.dplang.lang.ConstantExpression">ConstantExpression</a></li>
<li><a title="dplang.dplang.lang.NumberExpression" href="#dplang.dplang.lang.NumberExpression">NumberExpression</a></li>
<li><a title="dplang.dplang.lang.SignalExpression" href="#dplang.dplang.lang.SignalExpression">SignalExpression</a></li>
<li><a title="dplang.dplang.lang.WindowExpression" href="#dplang.dplang.lang.WindowExpression">WindowExpression</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dplang.dplang.lang.Expression.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def compile(x):
    if isinstance(x, Expression):
        return x.compile()
    return x</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dplang.dplang.lang.NumberExpression"><code class="flex name class">
<span>class <span class="ident">NumberExpression</span></span>
<span>(</span><span>n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumberExpression(Expression):
    def __init__(self, n):
        self.n = n

    def compile(self):
        return Signal(lambda dataset: self.n)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dplang.dplang.lang.Expression" href="#dplang.dplang.lang.Expression">Expression</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dplang.dplang.lang.NumberExpression.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self):
    return Signal(lambda dataset: self.n)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dplang.dplang.lang.Signal"><code class="flex name class">
<span>class <span class="ident">Signal</span></span>
<span>(</span><span>f)</span>
</code></dt>
<dd>
<div class="desc"><p>f :: DataSet -&gt; a</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Signal:
    def __init__(self, f):
        &#39;&#39;&#39;
        f :: DataSet -&gt; a
        &#39;&#39;&#39;
        self.f = f

    @staticmethod
    def eval(x, dataset):
        if isinstance(x, Signal):
            return x.f(dataset)
        return x

    def run(self, input):
        def generator():
            yield 1
        return generator</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="dplang.dplang.lang.Signal.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>x, dataset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def eval(x, dataset):
    if isinstance(x, Signal):
        return x.f(dataset)
    return x</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dplang.dplang.lang.Signal.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, input)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, input):
    def generator():
        yield 1
    return generator</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dplang.dplang.lang.SignalExpression"><code class="flex name class">
<span>class <span class="ident">SignalExpression</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>An input signal for the computation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalExpression(Expression):
    &#39;&#39;&#39;
    An input signal for the computation
    &#39;&#39;&#39;
    def __init__(self, name):
        self.name = name
        
    def compile(self):
        &#39;&#39;&#39;
        Signal Expression -&gt; Signal Value
        &#39;&#39;&#39;
        return Signal(lambda dataset: dataset[self.name])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dplang.dplang.lang.Expression" href="#dplang.dplang.lang.Expression">Expression</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dplang.dplang.lang.SignalExpression.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal Expression -&gt; Signal Value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self):
    &#39;&#39;&#39;
    Signal Expression -&gt; Signal Value
    &#39;&#39;&#39;
    return Signal(lambda dataset: dataset[self.name])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dplang.dplang.lang.WindowExpression"><code class="flex name class">
<span>class <span class="ident">WindowExpression</span></span>
<span>(</span><span>expr, size=1, stride=1)</span>
</code></dt>
<dd>
<div class="desc"><p>A windowed computation on signals</p>
<p>If window size is less than amount of data recieved, throw error.
The caller must check the window and ensure that the given data is a multiple of the window size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WindowExpression(Expression):
    &#39;&#39;&#39;
    A windowed computation on signals

    If window size is less than amount of data recieved, throw error.
    The caller must check the window and ensure that the given data is a multiple of the window size.
    &#39;&#39;&#39;
    def __init__(self, expr, size=1, stride=1):
        self.expr = expr
        self.size = size
        self.stride = stride
        
    def compile(self):
        &#39;&#39;&#39;
        Window -&gt; Signal
        &#39;&#39;&#39;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dplang.dplang.lang.Expression" href="#dplang.dplang.lang.Expression">Expression</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dplang.dplang.lang.WindowExpression.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Window -&gt; Signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self):
    &#39;&#39;&#39;
    Window -&gt; Signal
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dplang.dplang" href="index.html">dplang.dplang</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="dplang.dplang.lang.time_pattern" href="#dplang.dplang.lang.time_pattern">time_pattern</a></code></li>
<li><code><a title="dplang.dplang.lang.unit_map" href="#dplang.dplang.lang.unit_map">unit_map</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dplang.dplang.lang.parse" href="#dplang.dplang.lang.parse">parse</a></code></li>
<li><code><a title="dplang.dplang.lang.parse_time" href="#dplang.dplang.lang.parse_time">parse_time</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dplang.dplang.lang.ApplicationExpression" href="#dplang.dplang.lang.ApplicationExpression">ApplicationExpression</a></code></h4>
<ul class="">
<li><code><a title="dplang.dplang.lang.ApplicationExpression.compile" href="#dplang.dplang.lang.ApplicationExpression.compile">compile</a></code></li>
<li><code><a title="dplang.dplang.lang.ApplicationExpression.functions" href="#dplang.dplang.lang.ApplicationExpression.functions">functions</a></code></li>
<li><code><a title="dplang.dplang.lang.ApplicationExpression.is_supported" href="#dplang.dplang.lang.ApplicationExpression.is_supported">is_supported</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dplang.dplang.lang.ConstantExpression" href="#dplang.dplang.lang.ConstantExpression">ConstantExpression</a></code></h4>
<ul class="">
<li><code><a title="dplang.dplang.lang.ConstantExpression.compile" href="#dplang.dplang.lang.ConstantExpression.compile">compile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dplang.dplang.lang.DPLCompiler" href="#dplang.dplang.lang.DPLCompiler">DPLCompiler</a></code></h4>
<ul class="two-column">
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_BinOp" href="#dplang.dplang.lang.DPLCompiler.visit_BinOp">visit_BinOp</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_Call" href="#dplang.dplang.lang.DPLCompiler.visit_Call">visit_Call</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_Expr" href="#dplang.dplang.lang.DPLCompiler.visit_Expr">visit_Expr</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_For" href="#dplang.dplang.lang.DPLCompiler.visit_For">visit_For</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_Import" href="#dplang.dplang.lang.DPLCompiler.visit_Import">visit_Import</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_Module" href="#dplang.dplang.lang.DPLCompiler.visit_Module">visit_Module</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_Name" href="#dplang.dplang.lang.DPLCompiler.visit_Name">visit_Name</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_Num" href="#dplang.dplang.lang.DPLCompiler.visit_Num">visit_Num</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_Raise" href="#dplang.dplang.lang.DPLCompiler.visit_Raise">visit_Raise</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_Str" href="#dplang.dplang.lang.DPLCompiler.visit_Str">visit_Str</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_While" href="#dplang.dplang.lang.DPLCompiler.visit_While">visit_While</a></code></li>
<li><code><a title="dplang.dplang.lang.DPLCompiler.visit_With" href="#dplang.dplang.lang.DPLCompiler.visit_With">visit_With</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dplang.dplang.lang.Expression" href="#dplang.dplang.lang.Expression">Expression</a></code></h4>
<ul class="">
<li><code><a title="dplang.dplang.lang.Expression.compile" href="#dplang.dplang.lang.Expression.compile">compile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dplang.dplang.lang.NumberExpression" href="#dplang.dplang.lang.NumberExpression">NumberExpression</a></code></h4>
<ul class="">
<li><code><a title="dplang.dplang.lang.NumberExpression.compile" href="#dplang.dplang.lang.NumberExpression.compile">compile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dplang.dplang.lang.Signal" href="#dplang.dplang.lang.Signal">Signal</a></code></h4>
<ul class="">
<li><code><a title="dplang.dplang.lang.Signal.eval" href="#dplang.dplang.lang.Signal.eval">eval</a></code></li>
<li><code><a title="dplang.dplang.lang.Signal.run" href="#dplang.dplang.lang.Signal.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dplang.dplang.lang.SignalExpression" href="#dplang.dplang.lang.SignalExpression">SignalExpression</a></code></h4>
<ul class="">
<li><code><a title="dplang.dplang.lang.SignalExpression.compile" href="#dplang.dplang.lang.SignalExpression.compile">compile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dplang.dplang.lang.WindowExpression" href="#dplang.dplang.lang.WindowExpression">WindowExpression</a></code></h4>
<ul class="">
<li><code><a title="dplang.dplang.lang.WindowExpression.compile" href="#dplang.dplang.lang.WindowExpression.compile">compile</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>